module AutoDropdown exposing (State, Config, initialState, view,
    moveDown, moveUp, mouseEnter)

{-|

This is an HTML widget written in Gren. It renders and manages
a dropdown for a list of items that can be selected with the mouse,
or navigated with the keyboard.

Your application will hold one AutoDropdown.State and one
AutoDropdown.Config for every dropdown it instantiates.

These are the rules about State and Config:
* Always put AutoDropdown.State in your model
* Never put AutoDropdown.Config in your model

# Types

## Config

@docs Config

## State

@docs State

# Functions
@docs initialState
@docs view
@docs moveDown
@docs moveUp
@docs mouseEnter
-}


import Array
import Html exposing (Attribute, Html, ul, li, text)
import Html.Attributes exposing (style)
import Html.Events exposing (onClick, onMouseDown, onMouseEnter)
import Json.Decode as Decode

-- Heavily inspired by
-- https://github.com/wintvelt/elm-dropdown/blob/master/examples/Pure/Dropdown.elm

{-| This holds AutoDropdown state which is dynamic and can change
    during each update cycle. It's not managed by the dropdown,
    but managed by the application and passed into the
    dropdown during 'view'.
    This *always* goes into the application's Model.
    The application can and should change *isOpen* as needed.
    The dropdown can change *isOpen* to False when the user navigates
    too far up (see **moveUp**).
    The application should not modify **highlightedIndex**; the dropdown does
    that.
-}
type alias State =
    { isOpen : Bool
    , highlightedIndex: Maybe Int
    }

{-| Create an empty State object
-}
initialState : State
initialState =
    { isOpen = False
    , highlightedIndex = Nothing
    }

{-| The applications calls mouseEnter to tell the dropdown that the user's mouse
    has entered a dropdown item while it is being displayed.
    This function returns the new State.
-}
mouseEnter : Int -> Array String -> State -> State
mouseEnter idx items state =
    -- change to if Array.length
    if idx < Array.length items then
        { state
            | highlightedIndex = Just idx
        }
    else
        -- This should be impossible, but we have to cover it anyway
        { state
            | highlightedIndex = Nothing
        }


{-| The application calls moveUp to tell us the user is navigating up,
    likely by pressing the ArrowUp key.
    It returns the new State, and the Maybe highlighted item (String),
    in case the application needs it.
-}
moveUp : Array String -> State -> { state: State, highlighted: Maybe String }
moveUp items state =
    when state.isOpen is
        False -> { state = state, highlighted = Nothing }
        True ->
            when state.highlightedIndex is
                Nothing -> { state = state, highlighted = Nothing }
                Just idx -> definitelyMoveUp idx items state

-- The moveDown code has decided we're definitely moving the index up
definitelyMoveUp : Int -> Array String -> State -> { state: State, highlighted: Maybe String }
definitelyMoveUp idx items state =
    if idx == 0 then
        -- Can't go any higher; close the dropdown
        { state =
            { state
                | isOpen = False
                , highlightedIndex = Nothing
            }
        , highlighted = Nothing
        }
    else
        let
            newIdx = idx - 1
        in
            if newIdx < Array.length items then
                let
                    newItem = Array.get newIdx items
                in
                    when newItem is
                        -- Impossible, but we handle it to appease the
                        -- compiler
                        Nothing -> { state = state, highlighted = Nothing }
                        Just _ ->
                            { state =
                                { state
                                    | highlightedIndex = Just newIdx
                                }
                            , highlighted = newItem
                            }
            else
                -- The caller called us at a weird time, when our
                -- highlighted index is larger than what the items allow for
                -- Move to the last item
                let
                    maxIdx = (Array.length items) - 1
                    lastItem = Array.get maxIdx items
                in
                    when lastItem is
                        -- Impossible, but we handle it to appease the
                        -- compiler
                        Nothing -> { state = state, highlighted = Nothing }
                        Just _ ->
                            { state =
                                { state
                                    | highlightedIndex = Just maxIdx
                                }
                            , highlighted = lastItem
                            }

{-| The application calls moveDown to tell us the user is navigating down,
    likely by pressing the ArrowDown key.
    **moveDown** will adjust the highlightedIndex appropriately.
    It returns the new State, and the Maybe highlighted item (String),
    in case the application needs it.
-}
moveDown : Array String -> State -> { state: State, highlighted: Maybe String }
moveDown items state =
    when state.isOpen is
        False ->
            if Array.length items > 0 then
                let
                    { state = newState, highlighted = highlighted } =
                        definitelyMoveDown -1 items state
                in
                    { state =
                        { newState
                            | isOpen = True
                        }
                    , highlighted = highlighted
                    }
            else
                { state = state, highlighted = Nothing }
        True ->
            let
                currentIdx = when state.highlightedIndex is
                    Nothing -> -1
                    Just idx -> idx
            in
                definitelyMoveDown currentIdx items state

-- The moveDown code has decided we're definitely moving the index down
definitelyMoveDown : Int -> Array String -> State -> { state: State, highlighted: Maybe String }
definitelyMoveDown idx items state =
    let
        newIdx = idx + 1
        newItem = Array.get newIdx items
    in
        when newItem is
            Just _ ->
                { state =
                    { state
                        | highlightedIndex = Just newIdx
                    }
                , highlighted = newItem
                }

            Nothing ->
                let
                    maxIdx = (Array.length items) - 1
                    lastItem = Array.get maxIdx items
                in
                    when lastItem is
                        -- Impossible, but we handle it to appease the
                        -- compiler
                        Nothing -> { state = state, highlighted = Nothing }
                        Just _ ->
                            { state =
                                { state
                                    | highlightedIndex = Just maxIdx
                                }
                            , highlighted = lastItem
                            }


{-| The Config has static information, which doesn't
    change during the life cycle of the AutoDropdown. It tells
    AutoDropdown which HTML.Attributes to add to the DropDown
    that it renders.
    This *never* goes into the application's Model.
    Its coupled to your View logic.
-}
type alias Config msg =
    -- For both mouseDownMsg and mouseEnterMsg,
    -- the application handles the msg in its update function,
    -- and updates the AutoDropdown.State that it has
    { mouseDownMsg : String -> msg
    , mouseEnterMsg : Int -> msg
    , ulAttrs : Array (Attribute msg)
    , liAttrs : Array (Attribute msg)
    , highlightedAttrs: Array (Attribute msg)
    }

{-| Render the HTML for the dropdown
-}
view : Config msg -> State -> Array String -> Html msg
view config state items =
    let
        displayStyle =
            if state.isOpen then
                style "display" "block"
            else
                style "display" "none"
        ulAttrs = config.ulAttrs ++ [ displayStyle ]
    in
        ul ulAttrs (Array.indexedMap (viewItem config state) items)

-- Render an individual <li> for the dropdown's <ul>
viewItem : Config msg -> State -> Int -> String -> Html msg
viewItem config state idx item =
    let
        liAttrs = config.liAttrs ++ [
            -- Use mousedown to capture the event before the input's blur event fires (which would
            -- hide the dropdown)
            onMouseDown (config.mouseDownMsg item),
            onMouseEnter (config.mouseEnterMsg idx)
            ]

        attrs =
            when state.highlightedIndex is
                Nothing -> liAttrs
                Just highlightedIndex ->
                    if idx == highlightedIndex then
                        liAttrs ++ config.highlightedAttrs
                    else liAttrs
    in
        li attrs [ text item ]
