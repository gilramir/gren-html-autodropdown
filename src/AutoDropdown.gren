module AutoDropdown exposing (State, Config, initialState, view,
    moveDown, moveUp, mouseEnter, mouseLeave)

import Array
import Html exposing (Attribute, Html, ul, li, text)
import Html.Attributes exposing (style)
import Html.Events exposing (onClick, onMouseDown, onMouseEnter, onMouseLeave)
import Json.Decode as Decode

-- Heavily inspired by
-- https://github.com/wintvelt/elm-dropdown/blob/master/examples/Pure/Dropdown.elm

{-| AutoDropdown state which is dynamic and can change
    during each update cycle. It's not managed by the dropdown,
    but managed by the application and passed into the
    dropdown during 'view'.
    This *always* goes into the application's Model.
-}
     --selectedItem : Maybe String
type alias State =
    { isOpen : Bool
    , highlightedIndex: Maybe Int
    }

     --selectedItem = Nothing
initialState : State
initialState =
    { isOpen = False
    , highlightedIndex = Nothing
    }

mouseEnter : Int -> Array String -> State -> State
mouseEnter idx items state =
    -- change to if Array.length
    when Array.get idx items is
        Nothing ->
            -- This should be impossible, but we have to cover it anyway
            { state
                | highlightedIndex = Nothing
            }

        Just item ->
            { state
                | highlightedIndex = Just idx
            }

mouseLeave : Int -> Array String -> State -> State
mouseLeave idx items state =
    when state.highlightedIndex is
        Nothing ->
            -- Shouldn't happen
            { state
                | highlightedIndex = Nothing
            }

        Just highlightedIndex ->
            if highlightedIndex == idx then
                { state
                    | highlightedIndex = Nothing
                }
            else
                -- How can this happen? Did MouseLeave get processed after MouseEnter
                -- to another item? If so, change nothing
                state

moveUp : Array String -> State -> { state: State, highlighted: Maybe String }
moveUp items state =
    when state.isOpen is
        False -> { state = state, highlighted = Nothing }
        True ->
            when state.highlightedIndex is
                Nothing -> { state = state, highlighted = Nothing }
                Just idx -> definitelyMoveUp idx items state

definitelyMoveUp : Int -> Array String -> State -> { state: State, highlighted: Maybe String }
definitelyMoveUp idx items state =
    if idx == 0 then
        -- Can't go any higher; close the dropdown
        { state =
            { state
                | isOpen = False
                , highlightedIndex = Nothing
            }
        , highlighted = Nothing
        }
    else
        let
            newIdx = idx - 1
        in
            if newIdx < Array.length items then
                let
                    newItem = Array.get newIdx items
                in
                    when newItem is
                        -- Impossible, but we handle it to appease the
                        -- compiler
                        Nothing -> { state = state, highlighted = Nothing }
                        Just _ ->
                            { state =
                                { state
                                    | highlightedIndex = Just newIdx
                                }
                            , highlighted = newItem
                            }
            else
                -- The caller called us at a weird time, when our
                -- highlighted index is larger than what the items allow for
                -- Move to the last item
                let
                    maxIdx = (Array.length items) - 1
                    lastItem = Array.get maxIdx items
                in
                    when lastItem is
                        -- Impossible, but we handle it to appease the
                        -- compiler
                        Nothing -> { state = state, highlighted = Nothing }
                        Just _ ->
                            { state =
                                { state
                                    | highlightedIndex = Just maxIdx
                                }
                            , highlighted = lastItem
                            }

moveDown : Array String -> State -> { state: State, highlighted: Maybe String }
moveDown items state =
    when state.isOpen is
        False ->
            if Array.length items > 0 then
                let
                    { state = newState, highlighted = highlighted } = definitelyMoveDown -1 items state
                in
                    { state =
                        { newState
                            | isOpen = True
                        }
                    , highlighted = highlighted
                    }
            else
                { state = state, highlighted = Nothing }
        True ->
            let
                currentIdx = when state.highlightedIndex is
                    Nothing -> -1
                    Just idx -> idx
            in
                definitelyMoveDown currentIdx items state

definitelyMoveDown : Int -> Array String -> State -> { state: State, highlighted: Maybe String }
definitelyMoveDown idx items state =
    let
        newIdx = idx + 1
        newItem = Array.get newIdx items
    in
        when newItem is
            Just _ ->
                { state =
                    { state
                        | highlightedIndex = Just newIdx
                    }
                , highlighted = newItem
                }

            Nothing ->
                let
                    maxIdx = (Array.length items) - 1
                    lastItem = Array.get maxIdx items
                in
                    when lastItem is
                        -- Impossible, but we handle it to appease the
                        -- compiler
                        Nothing -> { state = state, highlighted = Nothing }
                        Just _ ->
                            { state =
                                { state
                                    | highlightedIndex = Just maxIdx
                                }
                            , highlighted = lastItem
                            }


{-| The config is more static information, which doesn't
    change during the life cycle of the AutoDropdown.
    This *never* goes into the application's Model.
-}
type alias Config msg =
    -- The application handles the msg in its update function,
    -- and can update the AutoDropdown.State that it has
    { itemPickedMsg : String -> msg
    , mouseEnterMsg : Int -> msg
    , mouseLeaveMsg : Int -> msg
    , ulAttrs : Array (Attribute msg)
    , liAttrs : Array (Attribute msg)
    , highlightedAttrs: Array (Attribute msg)
    }

view : Config msg -> State -> Array String -> Html msg
view config state items =
    let
        displayStyle =
            if state.isOpen then
                style "display" "block"
            else
                style "display" "none"
        ulAttrs = config.ulAttrs ++ [ displayStyle ]
    in
        ul ulAttrs (Array.indexedMap (viewItem config state) items)


viewItem : Config msg -> State -> Int -> String -> Html msg
viewItem config state idx item =
    let
        liAttrs = config.liAttrs ++ [
            -- Use mousedown to capture the event before the input's blur event fires (which would
            -- hide the dropdown)
            onMouseDown (config.itemPickedMsg item),
            onMouseEnter (config.mouseEnterMsg idx),
            onMouseLeave (config.mouseEnterMsg idx)
            ]

        attrs =
            when state.highlightedIndex is
                Nothing -> liAttrs
                Just highlightedIndex ->
                    if idx == highlightedIndex then
                        liAttrs ++ config.highlightedAttrs
                    else liAttrs

    in
        li attrs [ text item ]
