module AutoDropdown exposing (State, Config, initialState, view,
    moveDown, moveUp, mouseEnter)

{-|

This is an HTML component written in Gren. It renders and manages
a dropdown for a list of items that can be selected with the mouse,
or navigated with the keyboard.

These are the rules about State and Config:
* Always put AutoDropdown.State in your model
* Never put AutoDropdown.Config in your model


@docs Config
@docs State
@docs initialState
@docs view
@docs moveDown
@docs moveUp
@docs mouseEnter
-}


import Array
import Html exposing (Attribute, Html, ul, li, text)
import Html.Attributes exposing (style)
import Html.Events exposing (onClick, onMouseDown, onMouseEnter)
import Json.Decode as Decode

-- Heavily inspired by
-- https://github.com/wintvelt/elm-dropdown/blob/master/examples/Pure/Dropdown.elm

{-| AutoDropdown state which is dynamic and can change
    during each update cycle. It's not managed by the dropdown,
    but managed by the application and passed into the
    dropdown during 'view'.
    This *always* goes into the application's Model.
-}
type alias State =
    { isOpen : Bool
    , highlightedIndex: Maybe Int
    }

{-| Create an empty State object
-}
initialState : State
initialState =
    { isOpen = False
    , highlightedIndex = Nothing
    }

{-| The caller tells use the user that the mouse has entered an item in the
dropdown.
-}
mouseEnter : Int -> Array String -> State -> State
mouseEnter idx items state =
    -- change to if Array.length
    if idx < Array.length items then
        { state
            | highlightedIndex = Just idx
        }
    else
        -- This should be impossible, but we have to cover it anyway
        { state
            | highlightedIndex = Nothing
        }


{-| The caller tells use the user is moving up (likely pressing the ArrowUp key.
    Adjust the highlightedIndex
-}
moveUp : Array String -> State -> { state: State, highlighted: Maybe String }
moveUp items state =
    when state.isOpen is
        False -> { state = state, highlighted = Nothing }
        True ->
            when state.highlightedIndex is
                Nothing -> { state = state, highlighted = Nothing }
                Just idx -> definitelyMoveUp idx items state

-- The moveDown code has decided we're definitely moving the index up
definitelyMoveUp : Int -> Array String -> State -> { state: State, highlighted: Maybe String }
definitelyMoveUp idx items state =
    if idx == 0 then
        -- Can't go any higher; close the dropdown
        { state =
            { state
                | isOpen = False
                , highlightedIndex = Nothing
            }
        , highlighted = Nothing
        }
    else
        let
            newIdx = idx - 1
        in
            if newIdx < Array.length items then
                let
                    newItem = Array.get newIdx items
                in
                    when newItem is
                        -- Impossible, but we handle it to appease the
                        -- compiler
                        Nothing -> { state = state, highlighted = Nothing }
                        Just _ ->
                            { state =
                                { state
                                    | highlightedIndex = Just newIdx
                                }
                            , highlighted = newItem
                            }
            else
                -- The caller called us at a weird time, when our
                -- highlighted index is larger than what the items allow for
                -- Move to the last item
                let
                    maxIdx = (Array.length items) - 1
                    lastItem = Array.get maxIdx items
                in
                    when lastItem is
                        -- Impossible, but we handle it to appease the
                        -- compiler
                        Nothing -> { state = state, highlighted = Nothing }
                        Just _ ->
                            { state =
                                { state
                                    | highlightedIndex = Just maxIdx
                                }
                            , highlighted = lastItem
                            }

{-| The caller tells use the user is moving down (likely pressing the ArrowDown key.
    Adjust the highlightedIndex
-}
moveDown : Array String -> State -> { state: State, highlighted: Maybe String }
moveDown items state =
    when state.isOpen is
        False ->
            if Array.length items > 0 then
                let
                    { state = newState, highlighted = highlighted } =
                        definitelyMoveDown -1 items state
                in
                    { state =
                        { newState
                            | isOpen = True
                        }
                    , highlighted = highlighted
                    }
            else
                { state = state, highlighted = Nothing }
        True ->
            let
                currentIdx = when state.highlightedIndex is
                    Nothing -> -1
                    Just idx -> idx
            in
                definitelyMoveDown currentIdx items state

-- The moveDown code has decided we're definitely moving the index down
definitelyMoveDown : Int -> Array String -> State -> { state: State, highlighted: Maybe String }
definitelyMoveDown idx items state =
    let
        newIdx = idx + 1
        newItem = Array.get newIdx items
    in
        when newItem is
            Just _ ->
                { state =
                    { state
                        | highlightedIndex = Just newIdx
                    }
                , highlighted = newItem
                }

            Nothing ->
                let
                    maxIdx = (Array.length items) - 1
                    lastItem = Array.get maxIdx items
                in
                    when lastItem is
                        -- Impossible, but we handle it to appease the
                        -- compiler
                        Nothing -> { state = state, highlighted = Nothing }
                        Just _ ->
                            { state =
                                { state
                                    | highlightedIndex = Just maxIdx
                                }
                            , highlighted = lastItem
                            }


{-| The config has static information, which doesn't
    change during the life cycle of the AutoDropdown.
    This *never* goes into the application's Model.
-}
type alias Config msg =
    -- For both mouseDownMsg and mouseEnterMsg,
    -- the application handles the msg in its update function,
    -- and updates the AutoDropdown.State that it has
    { mouseDownMsg : String -> msg
    , mouseEnterMsg : Int -> msg
    , ulAttrs : Array (Attribute msg)
    , liAttrs : Array (Attribute msg)
    , highlightedAttrs: Array (Attribute msg)
    }

{-| Render the HTML for the dropdown
-}
view : Config msg -> State -> Array String -> Html msg
view config state items =
    let
        displayStyle =
            if state.isOpen then
                style "display" "block"
            else
                style "display" "none"
        ulAttrs = config.ulAttrs ++ [ displayStyle ]
    in
        ul ulAttrs (Array.indexedMap (viewItem config state) items)

-- Render and individual <li> for the dropdown's <ul>
viewItem : Config msg -> State -> Int -> String -> Html msg
viewItem config state idx item =
    let
        liAttrs = config.liAttrs ++ [
            -- Use mousedown to capture the event before the input's blur event fires (which would
            -- hide the dropdown)
            onMouseDown (config.mouseDownMsg item),
            onMouseEnter (config.mouseEnterMsg idx)
            ]

        attrs =
            when state.highlightedIndex is
                Nothing -> liAttrs
                Just highlightedIndex ->
                    if idx == highlightedIndex then
                        liAttrs ++ config.highlightedAttrs
                    else liAttrs
    in
        li attrs [ text item ]
